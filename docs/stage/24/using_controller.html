<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=9" />
  <meta name="generator" content="Doxygen 1.8.13" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RDMnet: Using the Controller API</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <!--BEGIN CUSTOM SCRIPT-->
  <script type="text/javascript">
    $(function () {
      $.get('/RDMnet/docs/versions.txt', function (data) {
        if (data) {
          var lines = data.split('\n');
          if (lines.length > 0) {
            var version_select = $("#version_select").empty();
            lines.forEach(function (line) {
              line = line.trim();
              if (!line) {
                return;
              }
              line = line.split(':');
              var option_name = line[0].replace(/^v/, '');
              if (line.length > 1) {
                option_name += ' (' + line[1] + ')';
              }
              var option_val = '/RDMnet/docs/' + line[0];
              var option = $('<option></option>').attr("value", option_val)
                .text(option_name);
              if (window.location.pathname.match('docs/' + line[0])) {
                option = option.attr("selected", "selected");
              }
              version_select.append(option);
            });
          }
        }
      }, 'text');
    });
  </script>
  <!--END CUSTOM SCRIPT-->
</head>
<body>
  <div id="top">
    <!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0" style="width: 100%">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
              <div id="projectname">RDMnet
                &#160;<span id="projectnumber">Staging for pull request 24</span>
              </div>
              <div id="projectbrief">Implementation of ANSI E1.33 (RDMnet)</div>
            </td>
            <!--BEGIN CUSTOM INSERTED SECTION-->
            <td style="text-align: right; padding-right: 0.5em">
              <div id="otherversions">
                View other versions:
                <select id="version_select" onchange="location = this.value">
                </select>
              </div>
            </td>
            <!--END CUSTOM INSERTED SECTION-->
          </tr>
        </tbody>
      </table>
    </div>
    <!-- end header part --><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('using_controller.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Using the Controller API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The RDMnet Controller API exposes both a C and C++ language interface. The C++ interface is a header-only wrapper around the C interface.</p>
<h2>Initialization and Destruction</h2>
<p>The controller init and deinit functions should be called once each at application startup and shutdown time. These functions interface with the EtcPal <a class="elRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__log.html">log (Logging)</a> API to configure what happens when the library logs messages. Optionally pass an <a class="elRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/struct_etc_pal_log_params.html">EtcPalLogParams</a> structure to use this functionality. This structure can be shared across different ETC library modules.</p>
<p>The init function has the side-effect of initializing the core RDMnet library, which by default starts a background thread for handling periodic RDMnet functionality and receiving data (this behavior can be overridden at compile-time if an app wants more control over its threading, see <a class="el" href="group__rdmnetopts__core.html#ga9b5e95f5bf09fa48aaf36769c8044b3b" title="Spawn a thread internally to call rdmnet_core_tick(). ">RDMNET_USE_TICK_THREAD</a> and rdmnet_core_tick()). The deinit function joins this thread.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="controller_8h.html">rdmnet/controller.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// In some function called at startup...</span></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/struct_etc_pal_log_params.html">EtcPalLogParams</a> log_params;</div><div class="line"><span class="comment">// Initialize log_params...</span></div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> init_result = <a class="code" href="group__rdmnet__controller__c.html#gaa9c613491725fe8379a3fbf38da44d08">rdmnet_controller_init</a>(&amp;log_params);</div><div class="line"><span class="comment">// Or, to init without worrying about logs from the RDMnet library...</span></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> init_result = <a class="code" href="group__rdmnet__controller__c.html#gaa9c613491725fe8379a3fbf38da44d08">rdmnet_controller_init</a>(NULL);</div><div class="line"></div><div class="line"><span class="comment">// In some function called at shutdown...</span></div><div class="line">rdmnet_controller_deinit();</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cpp_2controller_8h.html">rdmnet/cpp/controller.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// In some function called at startup...</span></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_logger.html">etcpal::Logger</a> logger;</div><div class="line"><span class="comment">// Initialize and start logger...</span></div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_result.html">etcpal::Result</a> init_result = <a class="code" href="classrdmnet_1_1_controller.html#aea1ed2b389451e2e46938928752a305e">rdmnet::Controller::Init</a>(logger);</div><div class="line"></div><div class="line"><span class="comment">// Or, to init without worrying about logs from the RDMnet library...</span></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_result.html">etcpal::Result</a> init_result = <a class="code" href="classrdmnet_1_1_controller.html#aea1ed2b389451e2e46938928752a305e">rdmnet::Controller::Init</a>();</div><div class="line"></div><div class="line"><span class="comment">// In some function called at shutdown...</span></div><div class="line"><a class="code" href="classrdmnet_1_1_controller.html#a9f9d89fef9cb9c06f25222102d276470">rdmnet::Controller::Deinit</a>();</div></div><!-- fragment --><p>To create a controller instance, use the <a class="el" href="group__rdmnet__controller__c.html#ga1860f48d433795826ce3edc8f6963c51" title="Create a new instance of RDMnet controller functionality. ">rdmnet_controller_create()</a> function. Most apps will only need a single controller instance. One controller can monitor an arbitrary number of RDMnet scopes at once.</p>
<p>The RDMnet controller API is an asynchronous, callback-oriented API. On creation, you give the library a configuration struct containing, among other things, a set of function pointers to use as callbacks. Callbacks are dispatched from the thread context which calls rdmnet_core_tick().</p>
<div class="fragment"><div class="line"><a class="code" href="struct_rdmnet_controller_config.html">RdmnetControllerConfig</a> config;</div><div class="line"></div><div class="line"><span class="comment">// Sets optional values to defaults. Must pass your ESTA manufacturer ID. If you have not yet</span></div><div class="line"><span class="comment">// requested an ESTA manufacturer ID, the range 0x7ff0 to 0x7fff can be used for prototyping.</span></div><div class="line">rdmnet_controller_config_init(&amp;config, MY_ESTA_MANUFACTURER_ID_VAL);</div><div class="line"></div><div class="line"><span class="comment">// Each controller is a component that must have a Component ID (CID), which is simply a UUID. Pure</span></div><div class="line"><span class="comment">// redistributable software apps may generate a new CID on each run, but hardware-locked devices</span></div><div class="line"><span class="comment">// should use a consistent CID locked to a MAC address (a V3 or V5 UUID).</span></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__uuid.html#gabb977b5a218b4b62224c016bf3932f10">etcpal_generate_os_preferred_uuid</a>(&amp;config.<a class="code" href="struct_rdmnet_controller_config.html#a4c3f7d9a58af5033f9acd8c942bf81d9">cid</a>);</div><div class="line"></div><div class="line"><span class="comment">// Set the callback functions - defined elsewhere</span></div><div class="line"><span class="comment">// p_some_opaque_data is an opaque data pointer that will be passed back to each callback function</span></div><div class="line">RDMNET_CONTROLLER_SET_CALLBACKS(&amp;config, my_controller_connected_cb, my_controller_disconnected_cb,</div><div class="line">                                my_controller_client_list_update_cb, my_controller_rdm_response_received_cb,</div><div class="line">                                my_controller_status_received_cb, p_some_opaque_data);</div><div class="line"></div><div class="line"><span class="comment">// Needed to identify this controller to other controllers on the network. More on this later.</span></div><div class="line">RDMNET_CONTROLLER_SET_RDM_DATA(&amp;config, <span class="stringliteral">&quot;My Manufacturer Name&quot;</span>, <span class="stringliteral">&quot;My Product Name&quot;</span>, <span class="stringliteral">&quot;1.0.0&quot;</span>, <span class="stringliteral">&quot;My Device Label&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="group__rdmnet__controller__c.html#ga5efb988f5125417e2a1f4c2b6877dc35">rdmnet_controller_t</a> my_controller_handle;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> result = <a class="code" href="group__rdmnet__controller__c.html#ga1860f48d433795826ce3edc8f6963c51">rdmnet_controller_create</a>(&amp;config, &amp;my_controller_handle);</div><div class="line"><span class="keywordflow">if</span> (result == <a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#gga743b0648f0ca798ef29c9f69c6e255afae403d046b4ba4e81dce121266c2cca8d">kEtcPalErrOk</a>)</div><div class="line">{</div><div class="line">  <span class="comment">// Handle is valid and may be referenced in later calls to API functions.</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  <span class="comment">// Some error occurred, handle is not valid.</span></div><div class="line">}</div></div><!-- fragment --><p>In C++, instantiate an <a class="el" href="classrdmnet_1_1_controller.html" title="An instance of RDMnet Controller functionality. ">rdmnet::Controller</a> instance and call its Startup() function.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyControllerNotifyHandler : <span class="keyword">public</span> <a class="code" href="classrdmnet_1_1_controller_notify_handler.html">rdmnet::ControllerNotifyHandler</a></div><div class="line">{</div><div class="line">  <span class="comment">// Implement the ControllerNotifyHandler callbacks...</span></div><div class="line">};</div><div class="line"></div><div class="line">MyControllerNotifyHandler my_controller_notify_handler;</div><div class="line"></div><div class="line"><span class="comment">// Needed to identify this controller to other controllers on the network. More on this later.</span></div><div class="line"><a class="code" href="structrdmnet_1_1_controller_rdm_data.html">rdmnet::ControllerRdmData</a> my_rdm_data(<span class="stringliteral">&quot;My Manufacturer Name&quot;</span>,</div><div class="line">                                      <span class="stringliteral">&quot;My Product Name&quot;</span>,</div><div class="line">                                      <span class="stringliteral">&quot;1.0.0&quot;</span>,</div><div class="line">                                      <span class="stringliteral">&quot;My Device Label&quot;</span>);</div><div class="line"><a class="code" href="classrdmnet_1_1_controller.html">rdmnet::Controller</a> controller;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_result.html">etcpal::Result</a> result = controller.Startup(my_controller_notify_handler, my_rdm_data,</div><div class="line">                                           rdmnet::ControllerData::Default(MY_ESTA_MANUFACTURER_ID_VAL));</div><div class="line"><span class="keywordflow">if</span> (result)</div><div class="line">{</div><div class="line">  <span class="comment">// Controller is valid and running.</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  <span class="comment">// Startup failed, use result.code() or result.ToString() to inspect details</span></div><div class="line">}</div></div><!-- fragment --><h3>Managing Scopes</h3>
<p>A controller instance is initially created without any configured scopes. If the app has not been reconfigured by a user, the E1.33 RDMnet standard requires that the RDMnet default scope be configured automatically. There is a shortcut function for this, rdmnet_controller_add_default_scope().</p>
<p>Otherwise, use rdmnet_controller_add_scope() to add a custom configured scope.</p>
<p>Per the requirements of RDMnet, a scope string is always UTF-8 and is thus represented by a char[] in C and a std::string in C++.</p>
<div class="fragment"><div class="line"><span class="comment">// Add a default scope</span></div><div class="line"><a class="code" href="group__rdmnet__client.html#ga1da9c25a97d47dbccefdb05f715cab08">rdmnet_client_scope_t</a> default_scope_handle;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> result = rdmnet_controller_add_default_scope(my_controller_handle, &amp;default_scope_handle);</div><div class="line"></div><div class="line"><span class="comment">// Add a custom scope</span></div><div class="line"><a class="code" href="struct_rdmnet_scope_config.html">RdmnetScopeConfig</a> scope_config;</div><div class="line"><a class="code" href="group__rdmnet__client.html#ga0b906d1d6ed5fcc678e9c530e440b62f">RDMNET_CLIENT_SET_SCOPE</a>(&amp;scope_config, <span class="stringliteral">&quot;custom_scope_name&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="group__rdmnet__client.html#ga1da9c25a97d47dbccefdb05f715cab08">rdmnet_client_scope_t</a> custom_scope_handle;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> result = rdmnet_controller_add_scope(my_controller_handle, &amp;scope_config, &amp;custom_scope_handle);</div></div><!-- fragment --><p>Or, in C++:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> add_res = controller.AddDefaultScope();</div><div class="line"><span class="comment">// Or...</span></div><div class="line"><span class="keyword">auto</span> add_res = controller.AddScope(<span class="stringliteral">&quot;custom_scope_name&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (add_res)</div><div class="line">{</div><div class="line">  rdmnet::ScopeHandle default_scope_handle = *add_res;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  <span class="comment">// Handle error</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Error adding default scope: &#39;&quot;</span> &lt;&lt; add_res.result().ToString() &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span></div><div class="line">}</div></div><!-- fragment --><h3>Dynamic vs Static Scopes</h3>
<p>Adding a scope will immediately begin the scope connection state machine from the RDMnet tick thread. If a static configuration is not provided (using the <a class="el" href="group__rdmnet__client.html#ga0b906d1d6ed5fcc678e9c530e440b62f" title="Initialize an RdmnetScopeConfig struct with a scope string. ">RDMNET_CLIENT_SET_SCOPE()</a> macro to initialize an <a class="el" href="struct_rdmnet_scope_config.html" title="A set of configuration information for a single scope in which an RDMnet client is participating...">RdmnetScopeConfig</a>, or calling rdmnet::Controller::AddScope() with only one argument) the first action will be to attempt to discover brokers for this scope using DNS-SD. Once a broker is found, connection will be initiated automatically, and the result will be delivered via either the connected or connect_failed callback.</p>
<p>If a broker for a given scope has been configured with a static IP address and port, you can skip DNS-SD discovery by providing a static configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// Get configured static broker address</span></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/struct_etc_pal_sock_addr.html">EtcPalSockAddr</a> static_broker_addr;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__inet.html#gacc09a02c09d9798f46d1fb6e9e84b900">etcpal_inet_pton</a>(<a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__inet.html#gga847282e3fd17bf75ec83292326c455eea73ea615eceba61f26d92a63f3738f635">kEtcPalIpTypeV4</a>, <span class="stringliteral">&quot;192.168.2.1&quot;</span>, &amp;static_broker_addr.<a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/struct_etc_pal_sock_addr.html#a19cc8016f534a565f984438cfe911a9e">ip</a>);</div><div class="line">static_broker_addr.<a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/struct_etc_pal_sock_addr.html#a8e0798404bf2cf5dabb84c5ba9a4f236">port</a> = 8000;</div><div class="line"></div><div class="line"><a class="code" href="struct_rdmnet_scope_config.html">RdmnetScopeConfig</a> config;</div><div class="line"><a class="code" href="group__rdmnet__client.html#ga500c0af02a2db3a6b835f26cf304da85">RDMNET_CLIENT_SET_STATIC_SCOPE</a>(&amp;config, <span class="stringliteral">&quot;my_custom_scope&quot;</span>, static_broker_addr);</div><div class="line"><span class="comment">// Or:</span></div><div class="line"><a class="code" href="group__rdmnet__client.html#gab2855ff14aba079140f1070f80140247">RDMNET_CLIENT_SET_STATIC_DEFAULT_SCOPE</a>(&amp;config, static_broker_addr);</div><div class="line"></div><div class="line"><a class="code" href="group__rdmnet__client.html#ga1da9c25a97d47dbccefdb05f715cab08">rdmnet_client_scope_t</a> scope_handle;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> result = rdmnet_controller_add_scope(my_controller_handle, &amp;config, &amp;scope_handle);</div></div><!-- fragment --><p>Or, in C++:</p>
<div class="fragment"><div class="line"><span class="comment">// Get configured static broker address</span></div><div class="line"><span class="keyword">auto</span> static_broker_addr = <a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_sock_addr.html">etcpal::SockAddr</a>(<a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_ip_addr.html#a431892e2354d1b617e2dd0278b8a9f30">etcpal::IpAddr::FromString</a>(<span class="stringliteral">&quot;192.168.2.1&quot;</span>), 8000);</div><div class="line"><span class="keyword">auto</span> add_res = controller.AddScope(<span class="stringliteral">&quot;my_custom_scope&quot;</span>, static_broker_addr);</div><div class="line"><span class="comment">// Or:</span></div><div class="line"><span class="keyword">auto</span> add_res = controller.AddDefaultScope(static_broker_addr);</div></div><!-- fragment --><h3>Handling Callbacks</h3>
<p>The library will dispatch callback notifications from the context in which rdmnet_core_tick() is called (in the default configuration, this is a single dedicated worker thread). It is safe to call any RDMnet API function from any callback; in fact, this is the recommended way of handling many callbacks.</p>
<p>For example, a very common controller behavior will be to fetch a client list from the broker after a successful connection:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> controller_connected_callback(<a class="code" href="group__rdmnet__controller__c.html#ga5efb988f5125417e2a1f4c2b6877dc35">rdmnet_controller_t</a> handle, <a class="code" href="group__rdmnet__client.html#ga1da9c25a97d47dbccefdb05f715cab08">rdmnet_client_scope_t</a> scope_handle,</div><div class="line">                                   <span class="keyword">const</span> <a class="code" href="struct_rdmnet_client_connected_info.html">RdmnetClientConnectedInfo</a>* info, <span class="keywordtype">void</span>* context)</div><div class="line">{</div><div class="line">  <span class="comment">// Check handle and/or context as necessary...</span></div><div class="line">  rdmnet_controller_request_client_list(handle, scope_handle);</div><div class="line">}                                   </div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyControllerNotifyHandler::HandleConnectedToBroker(<a class="code" href="classrdmnet_1_1_controller.html">rdmnet::Controller</a>&amp; controller, rdmnet::ScopeHandle scope,</div><div class="line">                                                        <span class="keyword">const</span> <a class="code" href="struct_rdmnet_client_connected_info.html">RdmnetClientConnectedInfo</a>&amp; info)</div><div class="line">{</div><div class="line">  <span class="comment">// Check handle as necessary...</span></div><div class="line">  controller.RequestClientList(scope);</div><div class="line">}</div></div><!-- fragment --><h4>Connection Failure</h4>
<p>It's worth noting connection failure as a special case here. RDMnet connections can fail for many reasons, including user misconfiguration, network misconfiguration, components starting up or shutting down, programming errors, and more.</p>
<p>The <a class="el" href="struct_rdmnet_client_connect_failed_info.html" title="Information provided by the library about an unsuccessful RDMnet client connection. ">RdmnetClientConnectFailedInfo</a> and <a class="el" href="struct_rdmnet_client_disconnected_info.html" title="Information provided by the library about an RDMnet client connection that disconnected after a succe...">RdmnetClientDisconnectedInfo</a> structs passed back with the "connect failed" and "disconnected" callbacks respectively have comprehensive information about the failure, including enum values containing the library's categorization of the failure, protocol reason codes and socket errors where applicable. This information is typically used mostly for logging and debugging. Each of these codes has a respective <code>to_string()</code> function to aid in logging.</p>
<p>For programmatic use, the structs also contain a <code>will_retry</code> member which indicates whether the library plans to retry this connection in the background. The only circumstances under which the library will not retry is when a connection failure is determined to be either a programming error or a user misconfiguration. Some examples of these circumstances are:</p>
<ul>
<li>The broker explicitly rejected a connection with a reason code indicating a configuration error, such as <code>CONNECT_SCOPE_MISMATCH</code> or <code>CONNECT_DUPLICATE_UID</code>.</li>
<li>The library failed to create a network socket before the connection was initiated.</li>
</ul>
<h3>Discovering Devices</h3>
<p>To discover devices in RDMnet, you need to request a <em>Client List</em> from the broker you're connected to. In our API, this is very easy - as we saw in the callbacks section earlier, we can just call rdmnet_controller_request_client_list() or rdmnet::Controller::RequestClientList(). This sends the appropriate request to the broker, and the reply will come back in the "Client List Update" callback:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_client_list_update_cb(<a class="code" href="group__rdmnet__controller__c.html#ga5efb988f5125417e2a1f4c2b6877dc35">rdmnet_controller_t</a> handle, <a class="code" href="group__rdmnet__client.html#ga1da9c25a97d47dbccefdb05f715cab08">rdmnet_client_scope_t</a> handle,</div><div class="line">                              client_list_action_t list_action, <span class="keyword">const</span> ClientList* list, <span class="keywordtype">void</span>* context)</div><div class="line">{</div><div class="line">  <span class="comment">// Check handle and/or context as necessary</span></div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (list_action)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> kRdmnetClientListAppend:</div><div class="line">      <span class="comment">// These entries are </span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h3>Sending RDM Commands</h3>
<p>Build RDM commands using the <a class="el" href="struct_local_rdm_command.html" title="An RDMnet RDM command generated by this component. ">LocalRdmCommand</a> type. The library uses a naming convention where names beginning with <code>Local</code> represent data that is generated locally, whereas names beginning with <code>Remote</code> represent data received from a remote component.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_local_rdm_command.html">LocalRdmCommand</a> cmd;</div><div class="line"><span class="comment">// Build the RDM command using cmd.rdm...</span></div><div class="line">cmd.dest_uid = client_uid;</div><div class="line">cmd.dest_endpoint = E133_NULL_ENDPOINT; <span class="comment">// We&#39;re addressing this command to the default responder.</span></div><div class="line"></div><div class="line">uint32_t cmd_seq_num;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> result = rdmnet_controller_send_rdm_command(my_controller_handle, my_scope_handle, &amp;cmd, &amp;cmd_seq_num);</div><div class="line"><span class="keywordflow">if</span> (result == <a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#gga743b0648f0ca798ef29c9f69c6e255afae403d046b4ba4e81dce121266c2cca8d">kEtcPalErrOk</a>)</div><div class="line">{</div><div class="line">  <span class="comment">// cmd_seq_num identifies this command transaction. Store it for when a response is received.</span></div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="struct_local_rdm_command.html">LocalRdmCommand</a> cmd;</div><div class="line"><span class="comment">// Build the RDM command using cmd.rdm...</span></div><div class="line">cmd.dest_uid = client_uid;</div><div class="line">cmd.dest_endpoint = E133_NULL_ENDPOINT; <span class="comment">// We&#39;re addressing this command to the default responder.</span></div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_expected.html">etcpal::Expected&lt;uint32_t&gt;</a> result = controller.SendRdmCommand(my_scope_handle, cmd);</div><div class="line"><span class="keywordflow">if</span> (result)</div><div class="line">{</div><div class="line">  <span class="comment">// *result identifies this command transaction. Store it for when a response is received.</span></div><div class="line">}</div></div><!-- fragment --><h3>Handling RDM Responses</h3>
<p>Responses to commands you send will be delivered asynchronously through the "RDM response" callback. You may also receive "unsolicited responses" - asynchronous state updates from devices that don't correspond to changes you requested.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rdm_response_callback(<a class="code" href="group__rdmnet__controller__c.html#ga5efb988f5125417e2a1f4c2b6877dc35">rdmnet_controller_t</a> handle, <a class="code" href="group__rdmnet__client.html#ga1da9c25a97d47dbccefdb05f715cab08">rdmnet_client_scope_t</a> scope_handle,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="struct_remote_rdm_response.html">RemoteRdmResponse</a>* resp, <span class="keywordtype">void</span>* context)</div><div class="line">{</div><div class="line">  <span class="comment">// Check handle and/or context as necessary...</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (resp-&gt;seq_num == 0)</div><div class="line">  {</div><div class="line">    <span class="comment">// This is an unsolicited RDM response - an asynchronous update about a change you didn&#39;t</span></div><div class="line">    <span class="comment">// initiate.</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="comment">// Verify resp-&gt;seq_num against the cmd_seq_num you stored earlier.</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// If resp-&gt;seq_num != 0, resp-&gt;cmd will contain the command you sent.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="struct_remote_rdm_resp_list_entry.html">RemoteRdmRespListEntry</a>* response = resp-&gt;<a class="code" href="struct_remote_rdm_response.html#a9b2f98f2a221e4e75557a5a5e3efb2f3">resp_list</a>; response; response = response-&gt;next)</div><div class="line">  {</div><div class="line">    <span class="comment">// Process the list of responses.</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (resp-&gt;<a class="code" href="struct_remote_rdm_response.html#ab5dd6470d680d9c5f2237907d37ef69b">more_coming</a>)</div><div class="line">  {</div><div class="line">    <span class="comment">// The library ran out of memory pool space while allocating responses - after this callback</span></div><div class="line">    <span class="comment">// returns, another will be delivered with the continuation of this response.</span></div><div class="line">    <span class="comment">// If RDMNET_DYNAMIC_MEM == 1 (the default on non-embedded platforms), this flag will never be set to true.</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyControllerNotifyHandler::HandleRdmResponse(<a class="code" href="classrdmnet_1_1_controller.html">rdmnet::Controller</a>&amp; controller, rdmnet::ScopeHandle scope,</div><div class="line">                                                  <span class="keyword">const</span> <a class="code" href="struct_remote_rdm_response.html">RemoteRdmResponse</a>&amp; resp)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (resp.seq_num == 0)</div><div class="line">  {</div><div class="line">    <span class="comment">// This is an unsolicited RDM response - an asynchronous update about a change you didn&#39;t</span></div><div class="line">    <span class="comment">// initiate.</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="comment">// Verify resp.seq_num against the result of rdmnet::Controller::SendRdmCommand() you stored earlier.</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// If resp-&gt;seq_num != 0, resp.cmd will contain the command you sent.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="struct_remote_rdm_resp_list_entry.html">RemoteRdmRespListEntry</a>* response = resp.<a class="code" href="struct_remote_rdm_response.html#a9b2f98f2a221e4e75557a5a5e3efb2f3">resp_list</a>; response; response = response-&gt;next)</div><div class="line">  {</div><div class="line">    <span class="comment">// Process the list of responses.</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (resp.<a class="code" href="struct_remote_rdm_response.html#ab5dd6470d680d9c5f2237907d37ef69b">more_coming</a>)</div><div class="line">  {</div><div class="line">    <span class="comment">// The library ran out of memory pool space while allocating responses - after this callback</span></div><div class="line">    <span class="comment">// returns, another will be delivered with the continuation of this response.</span></div><div class="line">    <span class="comment">// If RDMNET_DYNAMIC_MEM == 1 (the default on non-embedded platforms), this flag will never be set to true.</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>If something went wrong while either a broker or device was processing your message, you will get a response called an "RPT Status". There is a separate callback for handling these messages.</p>
<p>When you send an RDM command, you start a transaction that is identified by a 32-bit sequence number. That transaction is considered completed when you get either an RDM Response or an RPT Status containing that same sequence number.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rpt_status_callback(<a class="code" href="group__rdmnet__controller__c.html#ga5efb988f5125417e2a1f4c2b6877dc35">rdmnet_controller_t</a> handle, <a class="code" href="group__rdmnet__client.html#ga1da9c25a97d47dbccefdb05f715cab08">rdmnet_client_scope_t</a> handle, <span class="keyword">const</span> <a class="code" href="struct_remote_rpt_status.html">RemoteRptStatus</a>* status,</div><div class="line">                         <span class="keywordtype">void</span>* context)</div><div class="line">{</div><div class="line">  <span class="comment">// Check handle and/or context as necessary...</span></div><div class="line"></div><div class="line">  <span class="comment">// Verify status-&gt;seq_num against the cmd_seq_num you stored earlier.</span></div><div class="line"></div><div class="line">  <span class="keywordtype">char</span> uid_str[<a class="codeRef" doxygen="/home/vsts/work/1/s/external/RDM/docs/RDM.tag:https://etclabs.github.io/RDM/docs/head/" href="https://etclabs.github.io/RDM/docs/head/group__uid.html#gaca68c70b4aca047a5b8ff73e9d73b492">RDM_UID_STRING_BYTES</a>];</div><div class="line">  <a class="codeRef" doxygen="/home/vsts/work/1/s/external/RDM/docs/RDM.tag:https://etclabs.github.io/RDM/docs/head/" href="https://etclabs.github.io/RDM/docs/head/group__uid.html#ga90190789ec0a4c7262c47e2d7a1fdf43">rdm_uid_to_string</a>(&amp;status-&gt;source_uid, uid_str);</div><div class="line">  printf(<span class="stringliteral">&quot;Error sending RDM command to device %s: &#39;%s&#39;\n&quot;</span>, uid_str, rpt_status_code_to_string(status-&gt;msg.<a class="code" href="struct_rpt_status_msg.html#ad1e92880377c93c4e7a412a5bb57639c">status_code</a>));</div><div class="line"></div><div class="line">  <span class="comment">// Other logic as needed; remove our internal storage of the RDM transaction, etc.</span></div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyControllerNotifyHandler::HandleRptStatus(<a class="code" href="classrdmnet_1_1_controller.html">rdmnet::Controller</a>&amp; controller, rdmnet::ScopeHandle scope,</div><div class="line">                                                <span class="keyword">const</span> <a class="code" href="struct_remote_rpt_status.html">RemoteRptStatus</a>&amp; status)</div><div class="line">{</div><div class="line">  <span class="comment">// Verify status.seq_num against the result of rdmnet::Controller::SendRdmCommand() you stored earlier.</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Error sending RDM command to device &quot;</span> &lt;&lt; <a class="codeRef" doxygen="/home/vsts/work/1/s/external/RDM/docs/RDM.tag:https://etclabs.github.io/RDM/docs/head/" href="https://etclabs.github.io/RDM/docs/head/classrdm_1_1_uid.html">rdm::Uid</a>(status.source_uid).<a class="codeRef" doxygen="/home/vsts/work/1/s/external/RDM/docs/RDM.tag:https://etclabs.github.io/RDM/docs/head/" href="https://etclabs.github.io/RDM/docs/head/classrdm_1_1_uid.html#a19c380b03cea21d7ac7325136a131ff0">ToString</a>() &lt;&lt; <span class="stringliteral">&quot;: &#39;&quot;</span></div><div class="line">            &lt;&lt; rpt_status_code_to_string(status.msg.<a class="code" href="struct_rpt_status_msg.html#ad1e92880377c93c4e7a412a5bb57639c">status_code</a>) &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Other logic as needed; remove our internal storage of the RDM transaction, etc.</span></div><div class="line">}</div></div><!-- fragment --><h3>Handling RDM Commands</h3>
<p>In addition to getting information about responders, RDMnet controllers are required to respond to a basic set of RDM commands, which allows them to be identified by other controllers on the network. By default, this behavior is implemented completely within the library.</p>
<p>The default implementation provides read-only access to the standard set of data that is required to be readable from a controller. This includes the current scope(s) (<code>COMPONENT_SCOPE</code>), search domain (<code>SEARCH_DOMAIN</code>), and RDMnet communication diagnostic data (<code>TCP_COMMS_STATUS</code>), as well as some basic RDM data like the manufacturer (<code>MANUFACTURER_LABEL</code>), a description of the product (<code>DEVICE_MODEL_DESCRIPTION</code>), the software version in string form (<code>SOFTWARE_VERSION_LABEL</code>) and a user-settable label for the controller (<code>DEVICE_LABEL</code>). The library has access to all the information necessary for the first three items, since that information is necessary for RDMnet communication. Initial values for the last four items are provided to the library when creating a new controller instance, through the RDMNET_CONTROLLER_SET_RDM_DATA() macro or the <a class="el" href="structrdmnet_1_1_controller_rdm_data.html">rdmnet::ControllerRdmData</a> structure.</p>
<p>If you want to provide richer RDM responder functionality from your controller implementation, you can provide a set of callbacks to handle RDM commands. In this case, the library will no longer handle any RDM commands on your behalf and you must handle all of the above PIDs, as well as <code>SUPPORTED_PARAMETERS</code> and any additional ones you choose to support.</p>
<p>To use the library this way, you can:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_rdmnet_controller_config.html">RdmnetControllerConfig</a> config;</div><div class="line">rdmnet_controller_config_init(&amp;config, MY_ESTA_MANUFACTURER_ID_VAL);</div><div class="line"></div><div class="line"><span class="comment">// Generate CID and call RDMNET_CONTROLLER_SET_CALLBACKS() as above...</span></div><div class="line"></div><div class="line">RDMNET_CONTROLLER_SET_RDM_CMD_CALLBACKS(&amp;config, my_rdm_command_received_cb, my_llrp_rdm_command_received_cb);</div><div class="line"></div><div class="line"><a class="code" href="group__rdmnet__controller__c.html#ga5efb988f5125417e2a1f4c2b6877dc35">rdmnet_controller_t</a> my_controller_handle;</div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/group__etcpal__error.html#ga743b0648f0ca798ef29c9f69c6e255af">etcpal_error_t</a> result = <a class="code" href="group__rdmnet__controller__c.html#ga1860f48d433795826ce3edc8f6963c51">rdmnet_controller_create</a>(&amp;config, &amp;my_controller_handle);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>MyControllerRdmCommandHandler : <span class="keyword">public</span> <a class="code" href="classrdmnet_1_1_controller_rdm_command_handler.html">rdmnet::ControllerRdmCommandHandler</a></div><div class="line">{</div><div class="line">  <span class="comment">// Implement the ControllerRdmCommandHandler functions...</span></div><div class="line">};</div><div class="line"></div><div class="line">MyControllerRdmCommandHandler my_rdm_cmd_handler;</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/vsts/work/1/s/external/EtcPal/docs/etcpal.tag:https://etclabs.github.io/EtcPal/docs/head/" href="https://etclabs.github.io/EtcPal/docs/head/classetcpal_1_1_result.html">etcpal::Result</a> result = controller.Startup(my_controller_notify_handler, my_rdm_cmd_handler,</div><div class="line">                                           rdmnet::ControllerData::Default(MY_ESTA_MANUFACTURER_ID_VAL));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="getting_started.html">Getting Started</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
